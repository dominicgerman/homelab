{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to my Homelab Documentation","text":"<p>This site is a way for me to keep up-to-date documentation of my homelab. It will primarily contain info on my current setup as well as guides for how to re-create the systems I run at home.</p> <p>I had been using Obsidian to keep track of this info for the past couple years. I had also been posting tutorials and recaps on my blog. But I inevitably wind up having multiple sources of truth:</p> <p>Quote</p> <p>\"Where is that damn command I used for that one thing a few months ago? I thought I created a dedicated note in Obsidian for that project. Or maybe I wrote down those details in a blog post? I swear I wrote this down somewhere.\"</p> <p>Hopefully, I won't have that problem anymore.</p>"},{"location":"content-tabs/","title":"Content tabs","text":""},{"location":"content-tabs/#content-tabs","title":"Content Tabs","text":"<p>This is some examples of content tabs.</p>"},{"location":"content-tabs/#generic-content","title":"Generic Content","text":"Plain textUnordered listOrdered list <p>This is some plain text</p> <ul> <li>First item</li> <li>Second item</li> <li>Third item</li> </ul> <ol> <li>First item</li> <li>Second item</li> <li>Third item</li> </ol>"},{"location":"content-tabs/#code-blocks-in-content-tabs","title":"Code Blocks in Content Tabs","text":"PythonJavaScript <pre><code>def main():\n    print(\"Hello world!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>function main() {\n    console.log(\"Hello world!\");\n}\n\nmain();\n</code></pre>"},{"location":"services/jellyfin/","title":"Jellyfin","text":""},{"location":"services/jellyfin/#setup","title":"Setup","text":"<p>I'm assuming you have a newly spun up Docker container with Jellyfin running on the default port as demonstrated in the Jellyfin section of my media server setup guide.</p> <p>In a web browser, head to <code>http://your_server_IP:8096</code> and you should be greeted with a setup wizard. It should be pretty straightforward. One thing I always do is accidentally scroll right past the section where you're supposed to add a folder for Jellyfin to use as the actual media library. There, you'll want to add <code>/mnt/storage/media</code>.</p> <p>Tip</p> <p>Just a heads up in case this happens to you because it happened to me. The first time I ran <code>docker compose up -d</code>, it said permission denied so I just ran the command as root and didn't think twice. But this caused problems with permissions and Jellyfin presumably coudn't write to the directories it needed to do initialize the setup wizard. It essentially just skipped right over the setup wizard to the login screen. Took a while to figure out what I had done wrong.</p>"},{"location":"services/jellyfin/#hardware-transcoding","title":"Hardware Transcoding","text":"<p>Whether you have a discrete GPU or integrated graphics, it's worth enabling hardware accelerated video transcoding. If you're like me, you'll forget to enable it during the inital setup and only realize your mistake when you hear your CPU fan start going crazy after you fire up a movie.</p> <p>I have only ever used 9th gen or later Intel CPUs with integrated graphics and I have very few issues getting transcoding to work. You should be able to just set enable it through the Jellyfin settings page.</p>"},{"location":"setup/","title":"Guides","text":""},{"location":"setup/mediaserver/","title":"How to Set Up a Media Server","text":"<p>Alex from KTZ Systems has an in-depth installation tutorial for his \"Perfect Media Server\". The following is essentially a condensed version for my purposes.</p>"},{"location":"setup/mediaserver/#proxmox","title":"Proxmox","text":"<p>Download the Proxmox iso here. After the iso is in your downloads folder, run the following command to verify the checksum:</p> <pre><code>shasum -a 256 ~/Downloads/proxmox-ve_8.2-2.iso  # verify checksum\n</code></pre> <p>Flash it to a USB drive and then boot from it. During the setup process, you'll be asked to specify several things like the hostname, IP address, and an email address. The hostname is just something for proxmox to use internally. I usually go with something like <code>my-server-name.local</code> since it does require a full FDQN name.</p> <p>Run the Proxmox VE Helper Script to disable enterprise features like HA and the subscription nag among other things:</p> <pre><code>bash -c \"$(wget -qLO - https://github.com/community-scripts/ProxmoxVE/raw/main/misc/post-pve-install.sh)\"\n</code></pre> <p>Now is a good time to install <code>sudo</code> and <code>vim</code>:</p> <pre><code>apt update\napt install sudo\napt install vim \n</code></pre> <p>Add a user for yourself:</p> <pre><code>useradd -m -s /bin/bash dominic\u00a0 \u00a0\n</code></pre> <p>Give yourself a password</p> <pre><code>passwd dominic\n</code></pre> <p>Put yourself in the sudo group:</p> <pre><code>usermod -aG sudo dominic\n</code></pre> <p>Give yourself some special proxmox permissions:</p> <pre><code>pveum useradd dominic@pve -comment \"New Admin User\"\npveum aclmod / -user dominic@pve -role Administrator\n</code></pre> <p>Optional: Transfer SSH key</p> <p>You likely already have an ssh key on your personal computer. If you're on a Mac, you can run the following commands from your Mac's terminal so that you can log into your server without a password: <pre><code># clear any existing ssh keys for your server's hostname or IP address\nssh-keygen -R &lt;your-hostname-or-ip&gt;\n\n# copy public key from mac to server \nssh-copy-id &lt;your-user&gt;@&lt;your-hostname-or-ip&gt;\n</code></pre></p>"},{"location":"setup/mediaserver/#mergerfs","title":"Mergerfs","text":"<p>Log into your server via SSH as your new user if you haven't already.</p> <pre><code>ssh dominic@rackchoice\n</code></pre> <p>The command below pulls down the latest version of mergerfs from Github instead of relying on the apt repository which tends to lag behind the latest release. You can run it however often you want. If you already have the latest version, it will do nothing.</p> <pre><code>curl -s https://api.github.com/repos/trapexit/mergerfs/releases/latest | grep \"browser_download_url.*$(grep VERSION_CODENAME /etc/os-release | cut -d= -f2)_$(dpkg --print-architecture).deb\\\"\" | cut -d '\"' -f 4 | wget -qi - &amp;&amp; sudo dpkg -i mergerfs_*$(grep VERSION_CODENAME /etc/os-release | cut -d= -f2)_$(dpkg --print-architecture).deb &amp;&amp; rm mergerfs_*.deb\n</code></pre> <p>I also like to put the command in an <code>update_mergerfs.sh</code> script and set it to run every 3 months at 3AM on a cron job. Run <code>sudo crontab -e</code> to open the crontab for the root user and then add the following line to the end of the file:</p> <pre><code>0 3 1 */3 * /path/to/your/update_mergerfs.sh\n</code></pre> <p>Install <code>inxi</code> to identify your drives.</p> <pre><code>sudo apt install inxi\ninxi -xD  # list drives\nls /dev/disk/by-id # list drives by their immutable ids\n</code></pre> <p>Then identify the current <code>sdX</code> mappings for each drive:</p> <pre><code>ls -la /dev/disk/by-id/ata-ST400VN006-3CW104_ZW62V162  # for example\n/dev/disk/by-id/ata-ST4000VN006-3CW104_ZW62V162 -&gt; ../../sdb # output\n</code></pre> <p>Take note of the mappings. We'll need them for our <code>etc/fstab</code>.</p> <p>Run <code>sudo su</code> to switch user to <code>root</code>.</p> <p>For new drives (no pre-existing data you want to keep), run <code>gdisk /dev/sdX</code> where <code>X</code> is the drive you want to format. This will drop you into an interactive session. Follow these instructions:</p> <pre><code>Press `o` to create a new empty GPT partition table\n  * Proceed? (Y/N) - Y\nPress `n` to create a new partition\n  * Partition number (1-128, default 1): 1\n  * First sector (34-15628053134, default = 2048) or {+-}size{KMGTP}: &lt;leave blank&gt;\n  * Last sector (2048-15628053134, default = 15628053134) or {+-}size{KMGTP}: &lt;leave blank&gt;\n  * Hex code or GUID (L to show codes, Enter = 8300): 8300\nPress `p` to validate that 1 large partition is to be created\n  * Model: HGST HDN728080AL\n  * Number  Start (sector)    End (sector)  Size       Code  Name\n  * 1       2048              15628053134   7.3 TiB    8300  Linux filesystem\nPress `w` to write the changes made thus far\n  * Until this point, gdisk has been non-destructive\n  * Confirm that making these changes is OK and the changes queued so far will be executed\n</code></pre> <p>After you have done that for all your drives, create an <code>ext4</code> filesystem on each drive's newly created partition with <code>mkfs.ext4 /dev/sdX1</code>.</p> <p>Now we can create mountpoints for our new partitions:</p> <pre><code>mkdir /mnt/disk{1,2}  # or however many you need\nmkdir /mnt/parity1  # adjust this command based on your parity setup\nmkdir /mnt/storage  # this will be the main mergerfs mountpoint\n</code></pre> <p>Finally, we can edit <code>/etc/fstab</code> to tell our OS to mount our new partitions to our newly created mountpoints. This will run every time our machine boots. Here's an example:</p> /etc/fstab<pre><code>/dev/disk/by-id/ata-WDC_WD100EMAZ-00WJTA0_16G0Z7RZ-part1 /mnt/parity1 ext4 defaults 0 0\n/dev/disk/by-id/ata-WDC_WD100EMAZ-00WJTA0_16G10VZZ-part1 /mnt/disk1   ext4 defaults 0 0\n/dev/disk/by-id/ata-WDC_WD100EMAZ-00WJTA0_2YHV69AD-part1 /mnt/disk2   ext4 defaults 0 0\n\n/mnt/disk* /mnt/storage fuse.mergerfs defaults,nonempty,allow_other,use_ino,cache.files=off,moveonenospc=true,dropcacheonclose=true,minfreespace=200G,fsname=mergerfs 0 0\n</code></pre> <p>The last line is essentially your <code>mergerfs</code> config. You can read more about each option here.</p> <p>In order to reload the new fstab entries you've created and check them before rebooting, use <code>mount -a</code>. Then verify the mount points with <code>df -h</code>. If you had any existing files on your data disks they will be visible under <code>/mnt/storage</code>.</p> <p>Now's as good a time as any to change the owner of your new mergerfs pool to your non-root user so that when you start using samba and docker, you have write and read permissions at the Debian level:</p> <pre><code>sudo chown -R dominic:dominic /mnt/storage/\n</code></pre>"},{"location":"setup/mediaserver/#samba","title":"Samba","text":"<p>Install samba:</p> <pre><code>sudo apt install samba\n</code></pre> <p>Create/edit the samba config at <code>/etc/samba/smb.conf</code>. Here's an example:</p> /etc/samba/smb.conf<pre><code>[global]\n\u00a0 \u00a0 workgroup = DCG\n\u00a0 \u00a0 server string = rackchoice\n\u00a0 \u00a0 security = user\n\u00a0 \u00a0 guest ok = yes\n\u00a0 \u00a0 map to guest = Bad Password\n\u00a0 \u00a0 log file = /var/log/samba/%m.log\n\u00a0 \u00a0 max log size = 50\n\u00a0 \u00a0 printcap name = /dev/null\n\u00a0 \u00a0 load printers = no\n\n\n# Samba Shares\n[home]\n\u00a0 \u00a0 comment = dominic home folder\n\u00a0 \u00a0 path = /home/dominic\n\u00a0 \u00a0 browseable = yes\n\u00a0 \u00a0 read only = no\n\u00a0 \u00a0 guest ok = no\n\n[storage]\n\u00a0 \u00a0 comment = Primary Storage\n\u00a0 \u00a0 path = /mnt/storage\n\u00a0 \u00a0 browseable = yes\n\u00a0 \u00a0 read only = no\n\u00a0 \u00a0 guest ok = yes\n</code></pre> <p>Samba requires setting a password separately from that used for login. You may use an existing user or create a new one for this purpose.</p> <pre><code>sudo smbpasswd -a dominic\nsudo systemctl restart smbd\n</code></pre>"},{"location":"setup/mediaserver/#docker","title":"Docker","text":"<p>Install docker:</p> <pre><code>curl -fsSL https://get.docker.com | sh\n</code></pre> <p>Check your user's <code>uid</code> and <code>gid</code> as well as the groups they are in:</p> <pre><code>id dominic\ngroups dominic\n</code></pre> <p>I needed to add my user to the docker group so that I could run docker commands without being root:</p> <pre><code>sudo usermod -aG docker dominic\n</code></pre> <p>Note</p> <p>You'll have to log out and log back in for those changes to take effect.</p>"},{"location":"setup/mediaserver/#jellyfin","title":"Jellyfin","text":"<p>Linuxserver.io has a Jellyfin image with instructions on how to set it up.</p> <p>Create a folder for your jellyfin files (config, cache, etc) to live. I just used my user's home folder since it's on a fast SSD and there's plenty of space.</p> <pre><code>mkdir /home/dominic/jellyfin\nchown -R 1000:1000 /home/dominic/jellyfin\n</code></pre> <p>Then create a <code>docker-compose.yml</code> in the <code>jellyfin</code> folder. Here's mine:</p> docker-compose.yml<pre><code>services:\n\u00a0 jellyfin:\n\u00a0 \u00a0 image: lscr.io/linuxserver/jellyfin:latest\n\u00a0 \u00a0 container_name: jellyfin\n\u00a0 \u00a0 environment:\n\u00a0 \u00a0 \u00a0 - PUID=1000\n\u00a0 \u00a0 \u00a0 - PGID=1000\n\u00a0 \u00a0 \u00a0 - TZ=America/Chicago\n\u00a0 \u00a0 \u00a0 - JELLYFIN_PublishedServerUrl=http://192.168.1.204\n\u00a0 \u00a0 volumes:\n\u00a0 \u00a0 \u00a0 - /home/dominic/jellyfin:/config\n\u00a0 \u00a0 \u00a0 - /mnt/storage/media/tv:/data/tvshows\n\u00a0 \u00a0 \u00a0 - /mnt/storage/media/movies:/data/movies\n\u00a0 \u00a0 ports:\n\u00a0 \u00a0 \u00a0 - 8096:8096\n\u00a0 \u00a0 restart: unless-stopped\n</code></pre> <p>Run <code>docker compose version</code> to make sure you have docker compose on your server.</p> <p>Then from your <code>jellyfin</code> directory, run <code>docker compose up -d</code> to start the app.</p> <p>You should now be able to setup Jellyfin at the server's IP address on port <code>8096</code>. When you're ready to do that, head to the Jellyfin section of this site.</p>"},{"location":"setup/mediaserver/#snapraid","title":"SnapRAID","text":"<p>Coming soon!</p> <p>I'm not using SnapRAID at the moment on my system. It's great, I'm just in between disk purchases and it doesn't make sense to add a parity drive to my current setup.</p>"},{"location":"setup/ventoy/","title":"Create a Reusable Boot Drive with Ventoy","text":""},{"location":"setup/ventoy/#introduction","title":"Introduction","text":"<p>I have several computers in my life. Currently I have 3 laptops (2 personal, 1 for work), 3 mini PCs, 3 desktop computers that have been converted into servers, and 2 Raspberry Pi single board computers. Most of these computers are servers that I run in my homelab which is basically just a playground for learning about IT and software development.</p> <p>One of the most important steps in standing up a new server is installing the operating system (OS). This is a tedious process that often involves flashing a USB drive with the disk image (ISO) of your desired operating system, an action that requires reformatting and erasing the drive. A lot of people have old 16GB or 32GB flash drives laying around which work great for this task since most operating systems are less than 32GB in total size. Unfortunately, I don't have a bunch of old, small flash drives that I can dedicate for burning disk images.</p>"},{"location":"setup/ventoy/#installation","title":"Installation","text":"<p>Ventoy is a free and open-source utility used for creating bootable USB media storage devices. It allows you to add multiple different operating system images to one USB drive and boot from them directly without reformatting the drive each time. At the moment, I have a single USB drive that contains isos for Arch Linux, Ubuntu Server, and Proxmox VE.</p> <p>To create your own, go to the Ventoy official website and download the latest version for your operating system. I download the <code>ventoy-1.0.99-linux.tar.gz</code> file as I was doing this from a linux machine.</p> <p>I then ran <code>sha256sum ventoy-1.0.99-linux.tar.gz</code> from the directory that contained my downloaded file. You'll want to compare the output of that command to the SHA-256 checksum for the file you downloaded. This will usually be listed alongside the download link or in a separate text file.</p> <p>I then inserted the USB drive I wanted to use as my Ventoy drive. I ran <code>lsblk</code> to identify it. In my case, the drive was called <code>sda</code>. I needed to mount it so I ran the following commands: the first creates a new directory for mounting the partition and the second mounts the partition:</p> <pre><code>sudo mkdir -p /mnt/usb1\nsudo mount /dev/sda1 /mnt/usb1\n</code></pre> <p>This is what I saw after running <code>lsblk</code></p> <pre><code>NAME                      MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nsda                         8:16   1 116.1G  0 disk\n\u2514\u2500sda1                      8:17   1 116.1G  0 part /mnt/usb1\n</code></pre> <p>I then expanded the Ventoy tarball and navigated into the new <code>ventoy-1.0.99</code> directory:</p> <pre><code>tar -xzf ventoy-1.0.99-linux.tar.gz \ncd ventoy-1.0.99\n</code></pre> <p>Lastly, I ran the Ventoy install script:</p> <pre><code>sudo ./Ventoy2Disk.sh -i /dev/sda\n</code></pre>"},{"location":"setup/ventoy/#conclusion","title":"Conclusion","text":"<p>If everything went well, you should have a newly formatted <code>/dev/sda</code> drive with a Ventoy partition mounted at <code>/mnt/usb1</code>. From here, you can copy as many isos as you want to the Ventoy partition. If you're like, you'll also label your dedicated \"Ventoy\" drive appropriately so you don't get it mixed up with others.</p>"},{"location":"topics/storage/","title":"Storage","text":""},{"location":"topics/storage/#types-of-disks","title":"Types of Disks","text":""},{"location":"topics/storage/#hdds-hard-disk-drives","title":"HDDs (Hard Disk Drives)","text":"<p>HDDs are comprised of read/write heads attached to an actuator arm and spinning hard discs, sort of like a record player. These drives are the best bang for your buck when it comes to capacity. Currently, they're about $20/TB new. However, they're also big, loud, and slow. And because they have moving parts, they're more prone to mechanical failure.</p> <p>They're best suited for tasks like transferring large files since those are read/written sequentially in continuous blocks. Hard drives are pretty bad at tasks that are mostly random reads/writes (like launching applications) where data is read/written from scattered locations all over the disk. This is because the disk head has to physically move around a lot more which increases latency. It also increases wear and tear on the drive.</p>"},{"location":"topics/storage/#ssds-solid-state-drives","title":"SSDs (Solid State Drives)","text":"<p>SSDs have no moving parts and rely instead on flash memory. This makes them better than HDDs in pretty much every category except capacity. They range from $50 to $75 per TB new depending on a variety of factors. However they're way smaller, quiet, and tend to last longer than mechanical drives due to their lack of moving parts.</p> <p>They excel at random reads/writes which makes them way more suitable for things like databases, operating systems, and launching applications. To be clear, they are better than HDDs in every possible way. If you had infinite money, you could just use SSDs for everything. But storage is pretty much always going to be the most expensive part of a home server build and HDDs are still a great solution for many use cases.</p> <p>SSDs come in two main varieties according to the interface by which they are connected to the computer: Non-Volaitle Memory Express drives (NVMe) and Serial Advanced Tecnology Attachment drives (SATA). NVMe SSDs connect directly to the CPU via the PCIE bus which makes them extremely fast. SATA drives connect through the chipset resulting in significantly lower bandwidth and higher latency. The SATA interface is also how most HDDs communicate with the computer.</p>"},{"location":"topics/storage/#ssd-speeds","title":"SSD Speeds","text":"Interface Speed SATA 3.0 6 Gigabits/s (600MB/s) PCIe 3.0 8 Gigatransfers/s per lane (1GB/s) PCIe 4.0 16 Gigatransfers/s per lane (2GB/s) PCIe 5.0 32 Gigatransfers/s per lane (4GB/s)"},{"location":"topics/storage/#ssd-form-factors","title":"SSD Form Factors","text":"<p>SSDs come in two main form factors: M.2 and 2.5-inch drives. In most cases, the smaller M.2 drives will be NVMe drives although SATA versions do exist. Conversely, most 2.5\" drives you come across will be SATA drives.</p>"},{"location":"topics/storage/#storage-devices-and-linux","title":"Storage Devices and Linux","text":""},{"location":"topics/storage/#disks-and-block-devices","title":"Disks and Block Devices","text":"<p>A disk is a physical storage device, such as an HDD or SSD. In Linux, disks are represented as block devices, meaning they handle data in fixed-size blocks rather than a stream of bytes. You can think of your disk as a physical entity, while a block device is how the Linux kernel interacts with it.</p> <p>Block devices allow random access to data, making them suitable for file systems. Block devices are typically named <code>/dev/sdX</code> for SATA/SCSI drives (e.g., <code>/dev/sda</code>, <code>/dev/sdb</code>) and <code>/dev/nvmeXnY</code> for NVMe drives (e.g., <code>/dev/nvme0n1</code>).</p>"},{"location":"topics/storage/#partitions","title":"Partitions","text":"<p>A partition is a logically defined section of a disk. A single disk can be split into multiple partitions, each functioning as an independent unit. Partitioning allows for multiple operating systems, different file systems, or separate storage uses on the same physical disk. Partitions are represented as numbered block devices, e.g., <code>/dev/sda1</code>, <code>/dev/sda2</code> for SATA disks or <code>/dev/nvme0n1p1</code> for NVMe drives.</p> <p>Partition Tables To manage partitions, a disk has a partition table that records partition boundaries. The main type is GPT (GUID Partition Table). It supports up to 128 partitions (on most OSes), has no practical size limit, and is required for UEFI booting.</p>"},{"location":"topics/storage/#how-partitions-relate-to-disks-and-block-devices","title":"How Partitions Relate to Disks and Block Devices","text":"<p>Partitions are subdivisions of a block device. The full disk (e.g., <code>/dev/sda</code>) is a block device, and its partitions (e.g., <code>/dev/sda1</code>, <code>/dev/sda2</code>) are also block devices but only represent part of the disk.</p>"},{"location":"topics/storage/#file-systems","title":"File Systems","text":"<p>A file system is a method for organizing and storing files on a partition. A file system determines how data is stored, accessed, and managed. Before using a partition, it must be formatted with a file system, such as:</p> <ul> <li>ext4 \u2013 Common on Linux.</li> <li>XFS \u2013 Good for large files, often used in enterprise storage.</li> <li>Btrfs \u2013 Copy-on-write, snapshots, used by some Linux distributions.</li> <li>ZFS \u2013 Advanced features, used in NAS and high-reliability systems.</li> <li>FAT32, exFAT, NTFS \u2013 Windows-compatible file systems.</li> </ul> <p>To create a file system on a partition:</p> <pre><code>mkfs.ext4 /dev/sda1  # Formats partition sda1 with ext4\n</code></pre>"},{"location":"topics/storage/#how-file-systems-relate-to-partitions-and-block-devices","title":"How File Systems Relate to Partitions and Block Devices","text":"<p>A file system sits on top of a partition, defining how data is stored. A partition may have a single file system, but some advanced file systems (like ZFS and LVM) span multiple disks. The file system makes the partition usable for storing files.</p>"},{"location":"topics/storage/#mounting","title":"Mounting","text":"<p>Linux does not use drive letters like Windows. Instead, a file system is mounted at a directory (mount point). The <code>/etc/fstab</code> file defines automatic mounts at boot. Example mount command:</p> <pre><code>mount /dev/sda1 /mnt/data\n</code></pre> <p>This makes the partition accessible at <code>/mnt/data</code>.</p>"},{"location":"topics/storage/#how-mounting-relates-to-file-systems-and-partitions","title":"How Mounting Relates to File Systems and Partitions","text":"<p>A partition contains a file system, and mounting makes it available to users and applications.</p>"},{"location":"topics/storage/#review","title":"Review","text":"<ul> <li>Disks are physical devices.</li> <li>Block devices represent disks and partitions in Linux.</li> <li>Partitions divide a disk into separate sections.</li> <li>File systems organize data within a partition.</li> <li>Mounting makes a file system accessible at a directory.</li> </ul>"}]}