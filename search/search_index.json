{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to my Homelab Documentation","text":"<p>This is where I try to keep up-to-date documentation for my homelab. My homelab is servers, networking gear, and applications I'm running both on my LAN and in the cloud. I'm frequently tearing down and rebuilding things and it's nice to have a record of how I set things up. Otherwise I wind up searching my ChatGPT/browser history every time I need to find something.</p>"},{"location":"#hardware","title":"Hardware","text":""},{"location":"#servers","title":"Servers","text":"naslabbeelink Component Spec / Rationale Cost CPU AMD Ryzen 5 2600 (6C/12T) $20 Motherboard Asrock B450 Pro4 $75 RAM 32 GB DDR4-3200 $50 PCIe_2 (x16 bifurcated) Intel Arc A310 (hardware accelerated transcoding) $120 m.2_1 (from PCIe_2) 1 TB NVMe SSD (single disk zfs pool for active VMs/containers) $60 m.2_2 (from PCIe_2) m.2 to 6-port SATA expansion card $30 PCIe_4 (x16) 10 Gb SFP+ card (Intel X520 chipset) $35 PCIe (x1) 4-port SATA expansion card $30 Bulk storage (zfs) 42TB usable (Four 14TB disks in RAIDZ1) $600 Backup storage Two 2TB SATA SSDs (zfs mirror) $240 Power Rosewill 650W Bronze PSU $50 Cooling Thermalright Tower Air Cooler $25 Case RSV-L4500U 4U Server Chassis (12 hotswap drive bays) $270 Total cost (USD) \u2248 $ <p>This machine doubles as my backup server and as a testing ground for new apps and technologies.</p> Device Model Notes CPU AMD Ryzen 9 5900X Bought used with mobo and RAM. I wanted something decently powerful for re-encoding my 4K Blu-ray discs as well as potentially running multiple VMs. Motherboard ASRock B450 PRO4 AM4 Definitely on the older side. Looking to upgrade in the near future. Case Rosewill 4U Server Chassis (RSV-L4500U) Found one on Facebook Marketplace for $100. Memory 64GB Corsair Vengence LPX DDR4 Came with the motherboard. Boot drive 256GB Samsung NVMe SSD Free99. Power supply Thermaltake Smart 500W 80+ Free99. <p>I use this mini PC to self-host public facing websites and apps. It runs Tailscale, Caddy, Pi-hole, and more.</p> Device Model Notes CPU Intel N100 Something like four (efficiency) cores and maybe eight PCI lanes total. Very low power and perfect for the light workloads it's used for. Motherboard --- Has one m.2 slot, dual 2.5G nics, and room for one 2.5\" SATA drive. Case Beelink EQ12 Memory 16GB DDR5 Single channel laptop memory. Officially only supports 16GB but anecdotally supports up to 32GB. Boot drive 500GB NVMe SSD Came with the machine."},{"location":"content-tabs/","title":"Content tabs","text":""},{"location":"content-tabs/#content-tabs","title":"Content Tabs","text":"<p>This is some examples of content tabs.</p>"},{"location":"content-tabs/#generic-content","title":"Generic Content","text":"Plain textUnordered listOrdered list <p>This is some plain text</p> <ul> <li>First item</li> <li>Second item</li> <li>Third item</li> </ul> <ol> <li>First item</li> <li>Second item</li> <li>Third item</li> </ol>"},{"location":"content-tabs/#code-blocks-in-content-tabs","title":"Code Blocks in Content Tabs","text":"PythonJavaScript <pre><code>def main():\n    print(\"Hello world!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>function main() {\n    console.log(\"Hello world!\");\n}\n\nmain();\n</code></pre>"},{"location":"applications/jellyfin/","title":"Jellyfin","text":""},{"location":"applications/jellyfin/#docker","title":"Docker","text":"<p>I prefer to run Jellyfin as a Docker container running on the default port as demonstrated in the Jellyfin section of my media server setup guide.</p> <p>Tip</p> <p>Just a heads up in case this happens to you because it happened to me. The first time I ran <code>docker compose up -d</code>, it said permission denied so I just ran the command as root and didn't think twice. But this caused problems with permissions and Jellyfin presumably couldn't write to the directories it needed to to initialize the setup wizard. It essentially just skipped right over the setup wizard to the login screen. Took a while to figure out what I had done wrong.</p>"},{"location":"applications/jellyfin/#clients","title":"Clients","text":"<p>While Jellyfin is primarily a server application, the project has a number of different clients it maintains. Some of them are great, some are terrible. The Apple TV client Swiftfin is one of the terrible ones. I used it for a while before switching to Infuse (Pro) which is very affordable and solves all sorts of problems. Well worth it if you ask me.</p> <p>I don't have a ton of experience with the other clients but I will update this section with more info over time.</p>"},{"location":"applications/jellyfin/#cli-tools","title":"CLI tools","text":"<p>For a while, my remuxing/re-encoding workflow was all done on one of my servers via the command line. This was because that server had the most powerful CPU and thus could re-encode 4K files the fastest. I have since simplified my workflow but I still sometimes make use of these tools. Here are some of the tools I installed:</p> <ul> <li><code>mkvtoolnix</code></li> <li><code>HandBrakeCLI</code></li> <li><code>ffmpeg</code></li> </ul> <p>And here are some commands I found useful:</p> <pre><code># remux a .m2ts file\nmkvmerge -o /path/to/output/file.mkv /path/to/source/file.m2ts\n\n# extract sample video clip\nsudo ffmpeg -i /path/to/source -ss 00:59:00 -t 00:02:00 -c copy /path/to/destination\n\n# Re-encode with Handbrake CLI\nsudo HandBrakeCLI --preset-import-file /path/to/preset.json -Z \"My Preset Name\" -i /path/to/src/file -o /path/output/file.mkv\n\n# List tracks in an mkv file\nmkvmerge -i /path/to/mkv/file\n\n# Extract subtitle track to .sup file\nmkvextract tracks /path/to/src/file TRACK_ID:/path/to/dest/file.sup\n</code></pre>"},{"location":"applications/jellyfin/#subtitles","title":"Subtitles","text":"<p>Since Jellyfin's Apple TV client (Swiftfin) cannot reliably handle Blu-ray subtitle tracks without transcoding, I was using this free subtitle conversion tool to convert the picture-based SUP files to text-based SRT files. After converting, I would co-locate the SRT file with the mkv file in my media library. Unfortunately, the Jellyfin client would still had issues and would periodically fail to load the external SRT file.</p> <p>Since then, I have switched to using Infuse Pro as my Apple TV client. Infuse direct plays my media files regardless of subtitle format without any issues.</p>"},{"location":"applications/jellyfin/#handbrake-presets","title":"Handbrake Presets","text":"<p>Software encoders like x264 and x265 are CPU-based, take longer, and use more electricity. However, they produce noticeably better results than hardware encoders like QSV or NVENC. Hardware encoders are great for on-the-fly transcoding since they're super fast and still produce reasonably good visual quality, especially below 1080p.</p> <p>I prefer to use lossless (remuxed) mkv files for 1080p content. If you can direct play these files (usually around 30GB per movie), you can enjoy the highest possible video and audio playback. If my client can't support the higher bitrate (or the audio codec, or the container, etc.), then I let Jellyfin use the Quick Sync Video (QSV) hardware transcoder that's part of my Intel chip's iGPU. This has to be enabled in the Jellyfin settings but it's well worth it.</p> <ul> <li>Presets like <code>veryfast</code> or <code>veryslow</code> affect file size but not quality.</li> <li>CRF 18 is near visually lossless for 1080p.</li> <li>Constant framerate, same as source is a good starting point.</li> </ul>"},{"location":"guides/mediaserver/","title":"How to Set Up a Media Server","text":"<p>Alex from KTZ Systems has an in-depth installation tutorial for his \"Perfect Media Server\". The following is essentially a condensed version for my purposes.</p>"},{"location":"guides/mediaserver/#proxmox","title":"Proxmox","text":"<p>Download the Proxmox iso here. After the iso is in your downloads folder, run the following command to verify the checksum:</p> <pre><code>shasum -a 256 ~/Downloads/proxmox-ve_8.2-2.iso  # verify checksum\n</code></pre> <p>Flash it to a USB drive and then boot from it. During the setup process, you'll be asked to specify several things like the hostname, IP address, and an email address. The hostname is just something for proxmox to use internally. I usually go with something like <code>my-server-name.local</code> since it does require a full FDQN name.</p> <p>Run the Proxmox VE Helper Script to disable enterprise features like HA and the subscription nag among other things:</p> <pre><code>bash -c \"$(wget -qLO - https://github.com/community-scripts/ProxmoxVE/raw/main/misc/post-pve-install.sh)\"\n</code></pre> <p>Now is a good time to install <code>sudo</code> and <code>vim</code>:</p> <pre><code>apt update\napt install sudo\napt install vim \n</code></pre> <p>Add a user for yourself:</p> <pre><code>useradd -m -s /bin/bash dominic\u00a0 \u00a0\n</code></pre> <p>Give yourself a password</p> <pre><code>passwd dominic\n</code></pre> <p>Put yourself in the sudo group:</p> <pre><code>usermod -aG sudo dominic\n</code></pre> <p>Give yourself some special proxmox permissions:</p> <pre><code>pveum useradd dominic@pve -comment \"New Admin User\"\npveum aclmod / -user dominic@pve -role Administrator\n</code></pre> <p>Optional: Transfer SSH key</p> <p>You likely already have an ssh key on your personal computer. If you're on a Mac, you can run the following commands from your Mac's terminal so that you can log into your server without a password: <pre><code># clear any existing ssh keys for your server's hostname or IP address\nssh-keygen -R &lt;your-hostname-or-ip&gt;\n\n# copy public key from mac to server \nssh-copy-id &lt;your-user&gt;@&lt;your-hostname-or-ip&gt;\n</code></pre></p>"},{"location":"guides/mediaserver/#mergerfs","title":"Mergerfs","text":"<p>Log into your server via SSH as your new user if you haven't already.</p> <pre><code>ssh dominic@rackchoice\n</code></pre> <p>The command below pulls down the latest version of mergerfs from Github instead of relying on the apt repository which tends to lag behind the latest release. You can run it however often you want. If you already have the latest version, it will do nothing.</p> <pre><code>curl -s https://api.github.com/repos/trapexit/mergerfs/releases/latest | grep \"browser_download_url.*$(grep VERSION_CODENAME /etc/os-release | cut -d= -f2)_$(dpkg --print-architecture).deb\\\"\" | cut -d '\"' -f 4 | wget -qi - &amp;&amp; sudo dpkg -i mergerfs_*$(grep VERSION_CODENAME /etc/os-release | cut -d= -f2)_$(dpkg --print-architecture).deb &amp;&amp; rm mergerfs_*.deb\n</code></pre> <p>I also like to put the command in an <code>update_mergerfs.sh</code> script and set it to run every 3 months at 3AM on a cron job. Run <code>sudo crontab -e</code> to open the crontab for the root user and then add the following line to the end of the file:</p> <pre><code>0 3 1 */3 * /path/to/your/update_mergerfs.sh\n</code></pre> <p>Install <code>inxi</code> to identify your drives.</p> <pre><code>sudo apt install inxi\ninxi -xD  # list drives\nls /dev/disk/by-id # list drives by their immutable ids\n</code></pre> <p>Then identify the current <code>sdX</code> mappings for each drive:</p> <pre><code>ls -la /dev/disk/by-id/ata-ST400VN006-3CW104_ZW62V162  # for example\n/dev/disk/by-id/ata-ST4000VN006-3CW104_ZW62V162 -&gt; ../../sdb # output\n</code></pre> <p>Take note of the mappings. We'll need them for our <code>etc/fstab</code>.</p> <p>Run <code>sudo su</code> to switch user to <code>root</code>.</p> <p>For new drives (no pre-existing data you want to keep), run <code>gdisk /dev/sdX</code> where <code>X</code> is the drive you want to format. This will drop you into an interactive session. Follow these instructions:</p> <pre><code>Press `o` to create a new empty GPT partition table\n  * Proceed? (Y/N) - Y\nPress `n` to create a new partition\n  * Partition number (1-128, default 1): 1\n  * First sector (34-15628053134, default = 2048) or {+-}size{KMGTP}: &lt;leave blank&gt;\n  * Last sector (2048-15628053134, default = 15628053134) or {+-}size{KMGTP}: &lt;leave blank&gt;\n  * Hex code or GUID (L to show codes, Enter = 8300): 8300\nPress `p` to validate that 1 large partition is to be created\n  * Model: HGST HDN728080AL\n  * Number  Start (sector)    End (sector)  Size       Code  Name\n  * 1       2048              15628053134   7.3 TiB    8300  Linux filesystem\nPress `w` to write the changes made thus far\n  * Until this point, gdisk has been non-destructive\n  * Confirm that making these changes is OK and the changes queued so far will be executed\n</code></pre> <p>After you have done that for all your drives, create an <code>ext4</code> filesystem on each drive's newly created partition with <code>mkfs.ext4 /dev/sdX1</code>.</p> <p>Now we can create mountpoints for our new partitions:</p> <pre><code>mkdir /mnt/disk{1,2}  # or however many you need\nmkdir /mnt/parity1  # adjust this command based on your parity setup\nmkdir /mnt/storage  # this will be the main mergerfs mountpoint\n</code></pre> <p>Finally, we can edit <code>/etc/fstab</code> to tell our OS to mount our new partitions to our newly created mountpoints. This will run every time our machine boots. Here's an example:</p> /etc/fstab<pre><code>/dev/disk/by-id/ata-WDC_WD100EMAZ-00WJTA0_16G0Z7RZ-part1 /mnt/parity1 ext4 defaults 0 0\n/dev/disk/by-id/ata-WDC_WD100EMAZ-00WJTA0_16G10VZZ-part1 /mnt/disk1   ext4 defaults 0 0\n/dev/disk/by-id/ata-WDC_WD100EMAZ-00WJTA0_2YHV69AD-part1 /mnt/disk2   ext4 defaults 0 0\n\n/mnt/disk* /mnt/storage fuse.mergerfs defaults,nonempty,allow_other,use_ino,cache.files=off,moveonenospc=true,dropcacheonclose=true,minfreespace=200G,fsname=mergerfs 0 0\n</code></pre> <p>The last line is essentially your <code>mergerfs</code> config. You can read more about each option here.</p> <p>In order to reload the new fstab entries you've created and check them before rebooting, use <code>mount -a</code>. Then verify the mount points with <code>df -h</code>. If you had any existing files on your data disks they will be visible under <code>/mnt/storage</code>.</p> <p>Now's as good a time as any to change the owner of your new mergerfs pool to your non-root user so that when you start using samba and docker, you have write and read permissions at the Debian level:</p> <pre><code>sudo chown -R dominic:dominic /mnt/storage/\n</code></pre>"},{"location":"guides/mediaserver/#samba","title":"Samba","text":"<p>Install samba:</p> <pre><code>sudo apt install samba\n</code></pre> <p>Create/edit the samba config at <code>/etc/samba/smb.conf</code>. Here's an example:</p> /etc/samba/smb.conf<pre><code>[global]\n\u00a0 \u00a0 workgroup = DCG\n\u00a0 \u00a0 server string = rackchoice\n\u00a0 \u00a0 security = user\n\u00a0 \u00a0 guest ok = yes\n\u00a0 \u00a0 map to guest = Bad Password\n\u00a0 \u00a0 log file = /var/log/samba/%m.log\n\u00a0 \u00a0 max log size = 50\n\u00a0 \u00a0 printcap name = /dev/null\n\u00a0 \u00a0 load printers = no\n\n\n# Samba Shares\n[home]\n\u00a0 \u00a0 comment = dominic home folder\n\u00a0 \u00a0 path = /home/dominic\n\u00a0 \u00a0 browseable = yes\n\u00a0 \u00a0 read only = no\n\u00a0 \u00a0 guest ok = no\n\n[storage]\n\u00a0 \u00a0 comment = Primary Storage\n\u00a0 \u00a0 path = /mnt/storage\n\u00a0 \u00a0 browseable = yes\n\u00a0 \u00a0 read only = no\n\u00a0 \u00a0 guest ok = yes\n</code></pre> <p>Samba requires setting a password separately from that used for login. You may use an existing user or create a new one for this purpose.</p> <pre><code>sudo smbpasswd -a dominic\nsudo systemctl restart smbd\n</code></pre>"},{"location":"guides/mediaserver/#docker","title":"Docker","text":"<p>Install docker:</p> <pre><code>curl -fsSL https://get.docker.com | sh\n</code></pre> <p>Check your user's <code>uid</code> and <code>gid</code> as well as the groups they are in:</p> <pre><code>id dominic\ngroups dominic\n</code></pre> <p>I needed to add my user to the docker group so that I could run docker commands without being root:</p> <pre><code>sudo usermod -aG docker dominic\n</code></pre> <p>Note</p> <p>You'll have to log out and log back in for those changes to take effect.</p>"},{"location":"guides/mediaserver/#jellyfin","title":"Jellyfin","text":"<p>Linuxserver.io has a Jellyfin image with instructions on how to set it up.</p> <p>Create a folder for your jellyfin files (config, cache, etc) to live. I just used my user's home folder since it's on a fast SSD and there's plenty of space.</p> <pre><code>mkdir /home/dominic/jellyfin\nchown -R 1000:1000 /home/dominic/jellyfin\n</code></pre> <p>Then create a <code>docker-compose.yml</code> in the <code>jellyfin</code> folder. Here's mine:</p> docker-compose.yml<pre><code>services:\n\u00a0 jellyfin:\n\u00a0 \u00a0 image: lscr.io/linuxserver/jellyfin:latest\n\u00a0 \u00a0 container_name: jellyfin\n\u00a0 \u00a0 environment:\n\u00a0 \u00a0 \u00a0 - PUID=1000\n\u00a0 \u00a0 \u00a0 - PGID=1000\n\u00a0 \u00a0 \u00a0 - TZ=America/Chicago\n\u00a0 \u00a0 \u00a0 - JELLYFIN_PublishedServerUrl=http://192.168.1.204\n\u00a0 \u00a0 volumes:\n\u00a0 \u00a0 \u00a0 - /home/dominic/jellyfin:/config\n\u00a0 \u00a0 \u00a0 - /mnt/storage/media/tv:/data/tvshows\n\u00a0 \u00a0 \u00a0 - /mnt/storage/media/movies:/data/movies\n\u00a0 \u00a0 ports:\n\u00a0 \u00a0 \u00a0 - 8096:8096\n\u00a0 \u00a0 restart: unless-stopped\n</code></pre> <p>Run <code>docker compose version</code> to make sure you have docker compose on your server.</p> <p>Then from your <code>jellyfin</code> directory, run <code>docker compose up -d</code> to start the app.</p> <p>You should now be able to setup Jellyfin at the server's IP address on port <code>8096</code>. When you're ready to do that, head to the Jellyfin section of this site.</p>"},{"location":"guides/mediaserver/#snapraid","title":"SnapRAID","text":"<p>Coming soon!</p> <p>I'm not using SnapRAID at the moment on my system. It's great, I'm just in between disk purchases and it doesn't make sense to add a parity drive to my current setup.</p>"},{"location":"guides/ventoy/","title":"Create a Reusable Boot Drive with Ventoy","text":""},{"location":"guides/ventoy/#introduction","title":"Introduction","text":"<p>I have several computers in my life. Currently I have 3 laptops (2 personal, 1 for work), 3 mini PCs, 3 desktop computers that have been converted into servers, and 2 Raspberry Pi single board computers. Most of these computers are servers that I run in my homelab which is basically just a playground for learning about IT and software development.</p> <p>One of the most important steps in standing up a new server is installing the operating system (OS). This is a tedious process that often involves flashing a USB drive with the disk image (ISO) of your desired operating system, an action that requires reformatting and erasing the drive. A lot of people have old 16GB or 32GB flash drives laying around which work great for this task since most operating systems are less than 32GB in total size. Unfortunately, I don't have a bunch of old, small flash drives that I can dedicate for burning disk images.</p>"},{"location":"guides/ventoy/#installation","title":"Installation","text":"<p>Ventoy is a free and open-source utility used for creating bootable USB media storage devices. It allows you to add multiple different operating system images to one USB drive and boot from them directly without reformatting the drive each time. At the moment, I have a single USB drive that contains isos for Arch Linux, Ubuntu Server, and Proxmox VE.</p> <p>To create your own, go to the Ventoy official website and download the latest version for your operating system. I download the <code>ventoy-1.0.99-linux.tar.gz</code> file as I was doing this from a linux machine.</p> <p>I then ran <code>sha256sum ventoy-1.0.99-linux.tar.gz</code> from the directory that contained my downloaded file. You'll want to compare the output of that command to the SHA-256 checksum for the file you downloaded. This will usually be listed alongside the download link or in a separate text file.</p> <p>I then inserted the USB drive I wanted to use as my Ventoy drive. I ran <code>lsblk</code> to identify it. In my case, the drive was called <code>sda</code>. I needed to mount it so I ran the following commands: the first creates a new directory for mounting the partition and the second mounts the partition:</p> <pre><code>sudo mkdir -p /mnt/usb1\nsudo mount /dev/sda1 /mnt/usb1\n</code></pre> <p>This is what I saw after running <code>lsblk</code></p> <pre><code>NAME                      MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nsda                         8:16   1 116.1G  0 disk\n\u2514\u2500sda1                      8:17   1 116.1G  0 part /mnt/usb1\n</code></pre> <p>I then expanded the Ventoy tarball and navigated into the new <code>ventoy-1.0.99</code> directory:</p> <pre><code>tar -xzf ventoy-1.0.99-linux.tar.gz \ncd ventoy-1.0.99\n</code></pre> <p>Lastly, I ran the Ventoy install script:</p> <pre><code>sudo ./Ventoy2Disk.sh -i /dev/sda\n</code></pre>"},{"location":"guides/ventoy/#conclusion","title":"Conclusion","text":"<p>If everything went well, you should have a newly formatted <code>/dev/sda</code> drive with a Ventoy partition mounted at <code>/mnt/usb1</code>. From here, you can copy as many isos as you want to the Ventoy partition. If you're like, you'll also label your dedicated \"Ventoy\" drive appropriately so you don't get it mixed up with others.</p>"},{"location":"topics/storage/","title":"Storage","text":""},{"location":"topics/storage/#types-of-disks","title":"Types of Disks","text":""},{"location":"topics/storage/#hdds-hard-disk-drives","title":"HDDs (Hard Disk Drives)","text":"<p>HDDs are comprised of read/write heads attached to an actuator arm and spinning hard discs, sort of like a record player. These drives are the best bang for your buck when it comes to capacity. Currently, they're about $20/TB new. However, they're also big, loud, and slow. And because they have moving parts, they're more prone to mechanical failure.</p> <p>They're best suited for tasks like transferring large files since those are read/written sequentially in continuous blocks. Hard drives are pretty bad at tasks that are mostly random reads/writes (like launching applications) where data is read/written from scattered locations all over the disk. This is because the disk head has to physically move around a lot more which increases latency. It also increases wear and tear on the drive.</p>"},{"location":"topics/storage/#ssds-solid-state-drives","title":"SSDs (Solid State Drives)","text":"<p>SSDs have no moving parts and rely instead on flash memory. This makes them better than HDDs in pretty much every category except capacity. They range from $50 to $75 per TB new depending on a variety of factors. However they're way smaller, quiet, and tend to last longer than mechanical drives due to their lack of moving parts.</p> <p>They excel at random reads/writes which makes them way more suitable for things like databases, operating systems, and launching applications. To be clear, they are better than HDDs in every possible way. If you had infinite money, you could just use SSDs for everything. But storage is pretty much always going to be the most expensive part of a home server build and HDDs are still a great solution for many use cases.</p> <p>SSDs come in two main varieties according to the interface by which they are connected to the computer: Non-Volaitle Memory Express drives (NVMe) and Serial Advanced Tecnology Attachment drives (SATA). NVMe SSDs connect directly to the CPU via the PCIE bus which makes them extremely fast. SATA drives connect through the chipset resulting in significantly lower bandwidth and higher latency. The SATA interface is also how most HDDs communicate with the computer.</p>"},{"location":"topics/storage/#ssd-speeds","title":"SSD Speeds","text":"Interface Speed SATA 3.0 6 Gigabits/s (600MB/s) PCIe 3.0 8 Gigatransfers/s per lane (1GB/s) PCIe 4.0 16 Gigatransfers/s per lane (2GB/s) PCIe 5.0 32 Gigatransfers/s per lane (4GB/s)"},{"location":"topics/storage/#ssd-form-factors","title":"SSD Form Factors","text":"<p>SSDs come in two main form factors: M.2 and 2.5-inch drives. In most cases, the smaller M.2 drives will be NVMe drives although SATA versions do exist. Conversely, most 2.5\" drives you come across will be SATA drives.</p>"},{"location":"topics/storage/#storage-devices-and-linux","title":"Storage Devices and Linux","text":""},{"location":"topics/storage/#disks-and-block-devices","title":"Disks and Block Devices","text":"<p>A disk is a physical storage device, such as an HDD or SSD. In Linux, disks are represented as block devices, meaning they handle data in fixed-size blocks rather than a stream of bytes. You can think of your disk as a physical entity, while a block device is how the Linux kernel interacts with it.</p> <p>Block devices allow random access to data, making them suitable for file systems. Block devices are typically named <code>/dev/sdX</code> for SATA/SCSI drives (e.g., <code>/dev/sda</code>, <code>/dev/sdb</code>) and <code>/dev/nvmeXnY</code> for NVMe drives (e.g., <code>/dev/nvme0n1</code>).</p>"},{"location":"topics/storage/#partitions","title":"Partitions","text":"<p>A partition is a logically defined section of a disk. A single disk can be split into multiple partitions, each functioning as an independent unit. Partitioning allows for multiple operating systems, different file systems, or separate storage uses on the same physical disk. Partitions are represented as numbered block devices, e.g., <code>/dev/sda1</code>, <code>/dev/sda2</code> for SATA disks or <code>/dev/nvme0n1p1</code> for NVMe drives.</p> <p>Partition Tables To manage partitions, a disk has a partition table that records partition boundaries. The main type is GPT (GUID Partition Table). It supports up to 128 partitions (on most OSes), has no practical size limit, and is required for UEFI booting.</p>"},{"location":"topics/storage/#how-partitions-relate-to-disks-and-block-devices","title":"How Partitions Relate to Disks and Block Devices","text":"<p>Partitions are subdivisions of a block device. The full disk (e.g., <code>/dev/sda</code>) is a block device, and its partitions (e.g., <code>/dev/sda1</code>, <code>/dev/sda2</code>) are also block devices but only represent part of the disk.</p>"},{"location":"topics/storage/#file-systems","title":"File Systems","text":"<p>A file system is a method for organizing and storing files on a partition. A file system determines how data is stored, accessed, and managed. Before using a partition, it must be formatted with a file system, such as:</p> <ul> <li>ext4 \u2013 Common on Linux.</li> <li>XFS \u2013 Good for large files, often used in enterprise storage.</li> <li>Btrfs \u2013 Copy-on-write, snapshots, used by some Linux distributions.</li> <li>ZFS \u2013 Advanced features, used in NAS and high-reliability systems.</li> <li>FAT32, exFAT, NTFS \u2013 Windows-compatible file systems.</li> </ul> <p>To create a file system on a partition:</p> <pre><code>mkfs.ext4 /dev/sda1  # Formats partition sda1 with ext4\n</code></pre>"},{"location":"topics/storage/#how-file-systems-relate-to-partitions-and-block-devices","title":"How File Systems Relate to Partitions and Block Devices","text":"<p>A file system sits on top of a partition, defining how data is stored. A partition may have a single file system, but some advanced file systems (like ZFS and LVM) span multiple disks. The file system makes the partition usable for storing files.</p>"},{"location":"topics/storage/#mounting","title":"Mounting","text":"<p>Linux does not use drive letters like Windows. Instead, a file system is mounted at a directory (mount point). The <code>/etc/fstab</code> file defines automatic mounts at boot. Example mount command:</p> <pre><code>mount /dev/sda1 /mnt/data\n</code></pre> <p>This makes the partition accessible at <code>/mnt/data</code>.</p>"},{"location":"topics/storage/#how-mounting-relates-to-file-systems-and-partitions","title":"How Mounting Relates to File Systems and Partitions","text":"<p>A partition contains a file system, and mounting makes it available to users and applications.</p>"},{"location":"topics/storage/#review","title":"Review","text":"<ul> <li>Disks are physical devices.</li> <li>Block devices represent disks and partitions in Linux.</li> <li>Partitions divide a disk into separate sections.</li> <li>File systems organize data within a partition.</li> <li>Mounting makes a file system accessible at a directory.</li> </ul>"}]}